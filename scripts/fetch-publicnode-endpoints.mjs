/**
 * Fetch PublicNode free/public endpoints and write to files.
 *
 * What it does:
 * 1) Downloads https://publicnode.com/
 * 2) Extracts chain pages like https://<slug>.publicnode.com/
 * 3) For each chain page, extracts the "RPC Endpoint Link" URL(s) shown in the HTML
 * 4) Writes results to:
 *    - scripts/publicnode_endpoints.json
 *    - scripts/publicnode_endpoints.md
 *
 * Notes:
 * - PublicNode pages are partially dynamic; this script relies on endpoint URLs being
 *   present in the server-rendered HTML (the "RPC Endpoint Link" we see via fetch).
 * - If PublicNode changes their site, adjust the URL extraction regex.
 *
 * Run:
 *   node scripts/fetch-publicnode-endpoints.mjs
 */

import fs from 'node:fs/promises';
import path from 'node:path';

const HOME_URL = 'https://publicnode.com/';
const OUT_JSON = path.resolve('scripts/publicnode_endpoints.json');
const OUT_MD = path.resolve('scripts/publicnode_endpoints.md');

// Keep concurrency conservative to avoid getting blocked.
const CONCURRENCY = Number.parseInt(process.env.PUBLICNODE_CONCURRENCY || '6', 10);
const REQUEST_TIMEOUT_MS = Number.parseInt(process.env.PUBLICNODE_TIMEOUT_MS || '20000', 10);

function uniq(list) {
  return [...new Set(list)];
}

function nowIso() {
  return new Date().toISOString();
}

async function fetchText(url, { timeoutMs = REQUEST_TIMEOUT_MS } = {}) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const resp = await fetch(url, {
      method: 'GET',
      headers: {
        // Basic UA to reduce chance of getting a bot page.
        'User-Agent': 'Mozilla/5.0 (compatible; vitu-scraper/1.0; +https://vitufinance.com)',
        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
      },
      signal: controller.signal
    });
    if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
    return await resp.text();
  } finally {
    clearTimeout(t);
  }
}

function extractChainSlugsFromHome(homeHtml) {
  // Chain pages appear as:
  // - https://<slug>.publicnode.com
  // - https://<slug>.publicnode.com/
  // Example includes numeric slug like https://0g.publicnode.com
  const re = /https:\/\/([a-z0-9-]+)\.publicnode\.com(?:\/|\b)/gi;
  const slugs = [];
  let m;
  while ((m = re.exec(homeHtml)) !== null) {
    slugs.push(m[1]);
  }
  // Exclude non-chain subdomains; keep only "chain pages" like:
  // - ethereum, bsc, terra-classic, cronos-pos, 0g, ...
  // Drop "endpoint hosts" like:
  // - ethereum-rpc, bsc-rpc, cosmos-rest, injective-grpc-web, etc.
  const isEndpointHost = (s) =>
    /-(?:rpc|rest|grpc|grpc-web|ws|ws-rpc|beacon|beacon-api|http|solidity-http|solidity-grpc|evm-rpc|bor-rpc|heimdall-rpc|heimdall-rest)$/i.test(s);

  return uniq(slugs)
    .filter((s) => s && s !== 'www')
    .filter((s) => !isEndpointHost(s))
    .sort();
}

function extractEndpointLinksFromChainPage(chainHtml) {
  // The server-rendered HTML includes rows like:
  //   "RPC Endpoint Link" -> "https://bsc-rpc.publicnode.com"
  // We extract only the actual endpoint links (not the whole navigation list).
  // Note: the text "Endpoint Link" and the URL are often separated by HTML tags,
  // so we match across tags/newlines and then capture the first URL that appears
  // shortly after.
  const re = /\bEndpoint Link[\s\S]{0,400}?\b((?:https?|wss):\/\/[a-z0-9.-]*publicnode\.com[^\s<)"']*)/gi;
  const urls = [];
  let m;
  while ((m = re.exec(chainHtml)) !== null) {
    urls.push(m[1]);
  }

  return uniq(urls).sort();
}

async function mapLimit(items, limit, mapper) {
  const results = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await mapper(items[i], i);
    }
  }

  const workers = [];
  for (let i = 0; i < Math.max(1, limit); i++) workers.push(worker());
  await Promise.all(workers);
  return results;
}

function toMarkdown(results) {
  const lines = [];
  lines.push('# PublicNode Endpoints (Auto-fetched)');
  lines.push('');
  lines.push(`Source: ${HOME_URL}`);
  lines.push(`Fetched at: ${nowIso()}`);
  lines.push('');
  lines.push('This list is generated by `scripts/fetch-publicnode-endpoints.mjs`.');
  lines.push('');
  lines.push('## Endpoints');
  lines.push('');
  lines.push('| chain_slug | endpoints_found |');
  lines.push('|---|---|');

  for (const r of results) {
    const endpoints = (r.endpoints || []).length > 0 ? r.endpoints.join('<br/>') : '(none found)';
    lines.push(`| ${r.slug} | ${endpoints} |`);
  }

  lines.push('');
  lines.push('## Notes');
  lines.push('');
  lines.push('- Endpoints are free/public and may be rate-limited or pruned.');
  lines.push('- Always implement timeout + retry + rotation when using public RPCs.');
  return lines.join('\n');
}

async function main() {
  console.log(`[publicnode] fetching home: ${HOME_URL}`);
  const homeHtml = await fetchText(HOME_URL);
  const slugs = extractChainSlugsFromHome(homeHtml);

  if (slugs.length === 0) {
    throw new Error('No chain slugs found on publicnode.com (site structure may have changed).');
  }

  console.log(`[publicnode] discovered ${slugs.length} chain slugs`);

  const results = await mapLimit(slugs, CONCURRENCY, async (slug) => {
    const pageUrl = `https://${slug}.publicnode.com/`;
    try {
      const html = await fetchText(pageUrl);
      const endpoints = extractEndpointLinksFromChainPage(html);

      console.log(`[publicnode] ${slug}: ${endpoints.length} url(s)`);
      return { slug, pageUrl, endpoints };
    } catch (error) {
      console.warn(`[publicnode] ${slug}: failed (${error.message})`);
      return { slug, pageUrl, endpoints: [], error: error.message };
    }
  });

  const payload = {
    source: HOME_URL,
    fetchedAt: nowIso(),
    count: results.length,
    results
  };

  // Write minified JSON to avoid huge line counts.
  await fs.writeFile(OUT_JSON, JSON.stringify(payload) + '\n', 'utf8');
  await fs.writeFile(OUT_MD, toMarkdown(results) + '\n', 'utf8');

  console.log(`[publicnode] wrote: ${OUT_JSON}`);
  console.log(`[publicnode] wrote: ${OUT_MD}`);
}

main().catch((err) => {
  console.error('[publicnode] fatal:', err);
  process.exitCode = 1;
});

